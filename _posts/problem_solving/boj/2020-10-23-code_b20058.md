---
title:  "[java] ë°±ì¤€(BOJ) - ë§ˆë²•ì‚¬ ìƒì–´ì™€ íŒŒì´ì–´ìŠ¤í†°"
excerpt: "ë°±ì¤€ - ë§ˆë²•ì‚¬ ìƒì–´ì™€ íŒŒì´ì–´ìŠ¤í†° ë¬¸ì œí’€ì´"
toc: true
toc_sticky: true
categories:
  - Solution
tags:
  - boj
---
## ë¬¸ì œ  
[ë°±ì¤€-ë§ˆë²•ì‚¬ ìƒì–´ì™€ íŒŒì´ì–´ìŠ¤í†°](https://www.acmicpc.net/problem/20058){: target="_blank"}  
íŒŒì´ì–´ìŠ¤í†°ì´ ëª…ë ¹ì— ë”°ë¼ Që²ˆ ì‹œì „ í•œ í›„ ë‚¨ì•„ìˆëŠ” ì–¼ìŒì˜ í•©ê³¼ ì–¼ìŒ ì¤‘ ê°€ì¥ í° ë©ì–´ë¦¬ê°€ ì°¨ì§€í•˜ëŠ” ì¹¸ì˜ ê°¯ìˆ˜ë¥¼ êµ¬í•˜ëŠ” ë¬¸ì œ    

* ì œí•œ ì‚¬í•­  
ë§µì˜ í¬ê¸° 2^N : 2 â‰¤ `N` â‰¤ 6  
ë§ˆë²• ì‹œì „ íšŸìˆ˜ Q : 1 â‰¤ `Q` â‰¤ 1,000  
ê° ì–¼ìŒì˜ ì–‘ A[r][c] : 0 â‰¤ `A[r][c]` â‰¤ 100  
ì‹œì „ ë‹¨ê³„ L : 0 â‰¤ `Li` â‰¤ N  


## í’€ì´  
ë§µì˜ í¬ê¸°ëŠ” N*Nì´ ì•„ë‹Œ `2^N * 2^N`ì„ì„ ìœ ì˜í•´ì•¼í•œë‹¤  
2ì˜ NìŠ¹ìœ¼ë¡œ í¬ê¸°ë¥¼ êµ¬í•´ì„œ `map`ì´ë¼ëŠ” int ë°°ì—´ì„ ì„ ì–¸í•œë‹¤  

ê·¸ í›„ `2^L * 2^L`í¬ê¸°ë¡œ ë‚˜ëˆ ì„œ íšŒì „ì„ í•´ì•¼í•œë‹¤  
ë‹¨ê³„ì˜ ë²”ìœ„ë¥¼ ë³´ë©´, **0 ì´ìƒ N ì´í•˜**ì´ë‹¤  
2^L í¬ê¸°ë¡œ ë‚˜ëˆ ì„œ íšŒì „í•´ì•¼í•˜ë¯€ë¡œ 0ì´ê±°ë‚˜ Nì¸ê²½ìš°ì—ëŠ” <ins>íšŒì „í•˜ì§€ ì•ŠëŠ”ë‹¤</ins>  
(ğŸ’¥ì–¼ìŒì´ ë…¹ëŠ”ê³¼ì •ì€ ì§„í–‰í•´ì•¼í•¨ğŸ’¥)  


### ë¶„í•   
divide conquerëŠë‚Œìœ¼ë¡œ 4ë¶„í• ì„ í–ˆë‹¤  
`split(ì‹œì‘x, ëx, ì‹œì‘y, ëy, ê°€ë¡œê¸¸ì´)`ë©”ì„œë“œë¥¼ êµ¬í˜„í–ˆë‹¤  

ë¨¼ì € ë§µì˜ í¬ê¸°ë¥¼ sizeë¼ê³  í•œë‹¤ë©´  
ì´ˆê¸° í•¨ìˆ˜ ê°’ì€ `split(0, size, 0, size, 2^L)`ì´ë‹¤  
(`ëx`ê³¼ `ëy`ëŠ” í¬í•¨í•˜ì§€ ì•ŠëŠ”ë‹¤)  


ëŒ€ëµì ìœ¼ë¡œ ì„¤ëª…í•˜ìë©´ split í•¨ìˆ˜ì˜ ë¡œì§ì€ ì•„ë˜ì™€ ê°™ë‹¤  


* splití•¨ìˆ˜  
 1. ì¸ì 'ê°€ë¡œê¸¸ì´'ì™€ [ëx - ì‹œì‘x]ë¥¼ ë¹„êµí•œë‹¤  
 2. ë‘ ê°’ì´ ê°™ë‹¤ë©´ í˜„ì¬ ë²”ìœ„ê°€ íšŒì „í•  ë²”ìœ„ì´ë¯€ë¡œ 90ë„ íšŒì „í•œë‹¤  
 2-1. ë‘ ê°’ì´ ë‹¤ë¥´ë‹¤ë©´, í˜„ì¬ ë²”ìœ„ë¥¼ 4ë¶„í• í•´ì„œ splitì„ í˜¸ì¶œí•œë‹¤  

  * ì˜ˆì‹œ
	**L = 2**ì¸ ê²½ìš°, 4 * 4í¬ê¸°ë¡œ ë‚˜ëˆ ì„œ íšŒì „ì„ í•´ì•¼í•œë‹¤  
	mapì˜ í¬ê¸°ê°€ 8 * 8 ì´ë¼ë©´ `split(0, 8, 0, 8, 4)`ê°€ ëœë‹¤  
	* split(0, 8, 0, 8, 4)  
		splití•¨ìˆ˜ ë‚´ë¶€ì—ì„œ 4ì™€ (8-0)ì„ ë¹„êµí•œë‹¤  
		ë‘ ê°’ì´ ë‹¤ë¥´ë¯€ë¡œ 4ë¶„í• í•œ split ì„ í˜¸ì¶œí•œë‹¤  
		> split(0, 4, 0, 4, 4)  
		> split(0, 4, 4, 8, 4)  
		> split(4, 8, 0, 4, 4)  
		> split(4, 8, 4, 8, 4)  
		
		* split(0, 4, 0, 4, 4)  
			4ì™€ (4-0)ì„ ë¹„êµí•œë‹¤  
			ë‘ ê°’ì´ ê°™ìœ¼ë¯€ë¡œ 90ë„ íšŒì „í•œë‹¤  


### íšŒì „  
90ë„ íšŒì „í•˜ëŠ” ë¶€ë¶„ì€ ê°€ì¥ ì•ˆìª½ë¶€í„° íšŒì „í•˜ê²Œ í–ˆë‹¤  
```java
int mid = (ex - sx) / 2; // í˜„ì¬ ë¶„í• ì—ì„œ í•œ êµ¬ì—­ì˜ í¬ê¸°
// ê°€ì¥ ì•ˆìª½ì˜ ì¢Œìƒë‹¨ ìœ„ì¹˜
int mx = sx + mid - 1; 
int my = sy + mid - 1;
for (int i = 1; i <= s / 2; i++) {
	turn90(mx, my, i * 2); 
	mx--;
	my--;
}
```
![img](/assets/images/post/201023-1.jpg)  
[0, 0]ì—ì„œ [3, 3]ê¹Œì§€ì˜ ë¶„í• êµ¬ì—­ì„ íšŒì „í•´ì•¼ í•  ë•Œ,  
ê°€ì¥ ì•ˆìª½(ë…¸ë€ìƒ‰ ì )ì„ íšŒì „í•œ í›„  
ë°”ê¹¥ìª½(ì´ˆë¡ìƒ‰ ì )ìœ¼ë¡œ ì´ë™í•œë‹¤  

90ë„ íšŒì „ì€ map[mx][my]ë¶€í„° map[mx][my + i*2]ê¹Œì§€ tmpì— ë³µì‚¬í•œ ë‹¤ìŒ,  
ì™¼ìª½ ì„¸ë¡œë¥¼ ìƒë‹¨ìœ¼ë¡œ, í•˜ë‹¨ì„ ì™¼ìª½ ì„¸ë¡œë¡œ ... ì´ëŸ°ì‹ìœ¼ë¡œ ë³µì‚¬í–ˆë‹¤  
(ì½”ë“œì°¸ì¡°)  

### ì–¼ìŒ ë…¹ì´ê¸°  
íšŒì „ì„ ë§ˆì¹œ í›„, ê° ì–¼ìŒì€ ì¸ì ‘ ë°©í–¥ 3ê°œ ì´ìƒ ì–¼ìŒì´ ì¡´ì¬í•˜ì§€ ì•Šìœ¼ë©´ 1ì”© ê°ì†Œí•œë‹¤(ë…¹ëŠ”ë‹¤)  
ì´ë•Œ, ë°°ì—´ì„ ìˆœíšŒí•˜ë©´ì„œ ê°ì†Œì‹œí‚¤ë©´ ì•ˆëœë‹¤  
í˜„ì¬ ì¹¸ì´ 1ì´ê³  ë…¹ì•„ì•¼í•´ì„œ 0ìœ¼ë¡œ ë§Œë“¤ë©´, ë‹¤ìŒì¹¸ì— ì˜í–¥ì„ ë¯¸ì¹  ìˆ˜ ìˆê¸° ë–„ë¬¸ì´ë‹¤  


### ì‹œí–‰ì°©ì˜¤  
ì–¼ì¶” ì½”ë“œë¥¼ ì‘ì„±í•œ í›„ í…Œì¼€3ì˜ ë‹µì´ ë§ì§€ì•Šì•˜ë‹¤  
ë””ë²„ê¹…í•˜ë©´ì„œ íšŒì „ê°’ë„ í™•ì¸í–ˆëŠ”ë°, ì›ì¸ì€ ë‹¤ë¥¸ ê³³ì— ìˆì—ˆë‹¤  
Lì´ 0ì´ê±°ë‚˜ Nì´ë©´ continueë¡œ ì¨ì„œ <ins>ì–¼ìŒì´ ë…¹ëŠ”ë‹¨ê³„ë¥¼ ì§„í–‰í•˜ì§€ ì•Šì•˜ê¸° ë•Œë¬¸</ins>ì´ì—ˆë‹¤  
íšŒì „ë§Œ ì•ˆí• ë¿ì´ì§€ ë…¹ì•„ì•¼ í•  ì–¼ìŒì€ ë…¹ëŠ”ë‹¤..  


## ì†ŒìŠ¤ì½”ë“œ  
ì½”ë“œë„ ë¶„í•  ~~!  

### ë§µ ë¶„í•  ë° íšŒì „  
```java
private static void split(int sx, int ex, int sy, int ey, int s) {
	int mid = (ex - sx) / 2;
	if (ex - sx == s) {
	// 90ë„ ëŒë¦¬ê¸°
		int mx = sx + mid - 1;
		int my = sy + mid - 1;
		for (int i = 1; i <= s / 2; i++) {
			turn90(mx, my, i * 2);
			mx--;
			my--;
		}
	} else {
		split(sx, sx + mid, sy, sy + mid, s);
		split(sx, sx + mid, sy + mid, ey, s);
		split(sx + mid, ex, sy, sy + mid, s);
		split(sx + mid, ex, sy + mid, ey, s);
	}
}

private static void turn90(int sx, int sy, int width) {
	int tmp[] = new int[width];
	// ê°€ì¥ ìƒë‹¨ ë³µì‚¬
	for (int i = 0; i < width; i++) {
		tmp[i] = map[sx][sy + i];
	}
	// ì™¼ìª½ ì„¸ë¡œë¥¼ ìƒë‹¨ìœ¼ë¡œ ë³µì‚¬
	for (int i = 1; i < width; i++) {
		map[sx][sy + width - i - 1] = map[sx + i][sy];
	}
	// í•˜ë‹¨ì„ ì™¼ìª½ ì„¸ë¡œë¡œ ë³µì‚¬
	for (int i = 1; i < width; i++) {
		map[sx + i][sy] = map[sx + width - 1][sy + i];
	}
	// ì˜¤ë¥¸ìª½ ì„¸ë¡œë¥¼ í•˜ë‹¨ìœ¼ë¡œ ë³µì‚¬
	for (int i = 1; i < width; i++) {
		map[sx + width - 1][sy + i] = map[sx + width - i - 1][sy + width - 1];
	}
	for (int i = 0; i < width - 1; i++) {
		map[sx + i][sy + width - 1] = tmp[i];
	}
}
```

### ì–¼ìŒ ë…¹ëŠ” ë¶€ë¶„    
```java
//	 ì–¼ìŒ ë…¹ëŠ” ë¶€ë¶„
private static void melt() {
	q.clear();
	for (int i = 0; i < size; i++) {
		for (int j = 0; j < size; j++) {
			if (map[i][j] > 0) {
				int cnt = 0;
				for (int k = 0; k < 4; k++) {
					int nx = i + dx[k];
					int ny = j + dy[k];
					if (nx > -1 && ny > -1 && nx < size && ny < size && map[nx][ny] > 0) {
						cnt++;
					}
				}
				if (cnt < 3)
					q.add(new Point(i, j));
			}
		}
	}
	while (!q.isEmpty()) {
		Point curr = q.poll();
		map[curr.x][curr.y]--;
	}
}
```

### ë‚˜ë¨¸ì§€  
```java
import java.awt.Point;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;
public class b20058_ë§ˆë²•ì‚¬ìƒì–´ì™€íŒŒì´ì–´ìŠ¤í†° {

	private static int Q;
	private static int N;
	private static int[][] map;
	private static int[] order;
	static int dx[] = { 0, 0, 1, -1 };
	static int dy[] = { 1, -1, 0, 0 };
	static int size;
	static Queue<Point> q = new LinkedList<>();

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		N = Integer.parseInt(st.nextToken());
		Q = Integer.parseInt(st.nextToken());
		size = 1;

		for (int i = 0; i < N; i++) {
			size *= 2;
		}
		map = new int[size][size];
		order = new int[Q];
		for (int i = 0; i < size; i++) {
			st = new StringTokenizer(br.readLine());
			for (int j = 0; j < size; j++) {
				map[i][j] = Integer.parseInt(st.nextToken());
			}
		}

		st = new StringTokenizer(br.readLine());
		for (int i = 0; i < Q; i++) {
			order[i] = Integer.parseInt(st.nextToken());
		}
		for (int i = 0; i < Q; i++) {
			int L = order[i];
			if (L == 0 || L == N) {
				melt();
				continue;
			}
			int cell = 1;
			for (int j = 0; j < L; j++) {
				cell *= 2;
			}
			// íšŒì „
			split(0, size, 0, size, cell);
			// ì–¼ìŒ ë…¹ê¸°
			melt();
		}
		// ë§ˆì§€ë§‰ ì–¼ìŒ ì–‘ ì´í•©ê³¼ í° ë©ì–´ë¦¬ ì–¼ìŒê°¯ìˆ˜ êµ¬í•˜ëŠ” ë¶€ë¶„(bfs ì‚¬ìš©)
		long ans = 0;
		int max = 0;
		boolean chk[][] = new boolean[size][size];
		q.clear();
		for (int i = 0; i < size; i++) {
			for (int j = 0; j < size; j++) {
				if (map[i][j] > 0 && !chk[i][j]) {
					int cnt = 1;
					q.add(new Point(i, j));
					chk[i][j] = true;

					while (!q.isEmpty()) {
						Point curr = q.poll();
						ans += map[curr.x][curr.y];
						for (int k = 0; k < 4; k++) {
							int nx = curr.x + dx[k];
							int ny = curr.y + dy[k];
							if (nx > -1 && ny > -1 && nx < size && ny < size && !chk[nx][ny] && map[nx][ny] > 0) {
								q.add(new Point(nx, ny));
								chk[nx][ny] = true;
								cnt++;
							}
						}
					}
					max = Math.max(max, cnt);
				}
			}
		}
		// end
		System.out.println(ans);
		System.out.println(max);
	}
}
```