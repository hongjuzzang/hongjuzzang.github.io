---
title:  "[java] 백준(BOJ) - 마법사 상어와 파이어스톰"
excerpt: "백준 - 마법사 상어와 파이어스톰 문제풀이"
toc: true
toc_sticky: true
categories:
  - Solution
tags:
  - boj
---
## 문제  
[백준-마법사 상어와 파이어스톰](https://www.acmicpc.net/problem/20058){: target="_blank"}  
파이어스톰이 명령에 따라 Q번 시전 한 후 남아있는 얼음의 합과 얼음 중 가장 큰 덩어리가 차지하는 칸의 갯수를 구하는 문제    

* 제한 사항  
맵의 크기 2^N : 2 ≤ `N` ≤ 6  
마법 시전 횟수 Q : 1 ≤ `Q` ≤ 1,000  
각 얼음의 양 A[r][c] : 0 ≤ `A[r][c]` ≤ 100  
시전 단계 L : 0 ≤ `Li` ≤ N  


## 풀이  
맵의 크기는 N*N이 아닌 `2^N * 2^N`임을 유의해야한다  
2의 N승으로 크기를 구해서 `map`이라는 int 배열을 선언한다  

그 후 `2^L * 2^L`크기로 나눠서 회전을 해야한다  
단계의 범위를 보면, **0 이상 N 이하**이다  
2^L 크기로 나눠서 회전해야하므로 0이거나 N인경우에는 <ins>회전하지 않는다</ins>  
(💥얼음이 녹는과정은 진행해야함💥)  


### 분할  
divide conquer느낌으로 4분할을 했다  
`split(시작x, 끝x, 시작y, 끝y, 가로길이)`메서드를 구현했다  

먼저 맵의 크기를 size라고 한다면  
초기 함수 값은 `split(0, size, 0, size, 2^L)`이다  
(`끝x`과 `끝y`는 포함하지 않는다)  


대략적으로 설명하자면 split 함수의 로직은 아래와 같다  


* split함수  
 1. 인자 '가로길이'와 [끝x - 시작x]를 비교한다  
 2. 두 값이 같다면 현재 범위가 회전할 범위이므로 90도 회전한다  
 2-1. 두 값이 다르다면, 현재 범위를 4분할해서 split을 호출한다  

  * 예시
	**L = 2**인 경우, 4 * 4크기로 나눠서 회전을 해야한다  
	map의 크기가 8 * 8 이라면 `split(0, 8, 0, 8, 4)`가 된다  
	* split(0, 8, 0, 8, 4)  
		split함수 내부에서 4와 (8-0)을 비교한다  
		두 값이 다르므로 4분할한 split 을 호출한다  
		> split(0, 4, 0, 4, 4)  
		> split(0, 4, 4, 8, 4)  
		> split(4, 8, 0, 4, 4)  
		> split(4, 8, 4, 8, 4)  
		
		* split(0, 4, 0, 4, 4)  
			4와 (4-0)을 비교한다  
			두 값이 같으므로 90도 회전한다  


회전을 마친 후, 각 얼음은 인접 방향 3개 이상 얼음이 존재하지 않으면 1씩 감소한다(녹는다)  
이때, 배열을 순회하면서 감소시키면 안된다  
현재 칸이 1이고 녹아야해서 0으로 만들면, 다음칸에 영향을 미칠 수 있기 떄문이다  

### 회전  
90도 회전하는 부분은 가장 안쪽부터 회전하게 했다  
```java
int mid = (ex - sx) / 2; // 현재 분할에서 한 구역의 크기
// 가장 안쪽의 좌상단 위치
int mx = sx + mid - 1; 
int my = sy + mid - 1;
for (int i = 1; i <= s / 2; i++) {
	turn90(mx, my, i * 2); 
	mx--;
	my--;
}
```
[0, 0]에서 [3, 3]까지의 분할구역을 회전해야 할 때,  
가장 안쪽(노란색 점)을 회전한 후  
바깥쪽(초록색 점)으로 이동한다  
![img](/assets/images/post/201023-1.jpg)  



### 시행착오  
얼추 코드를 작성한 후 테케3의 답이 맞지않았다  
디버깅하면서 회전값도 확인했는데, 원인은 다른 곳에 있었다  
L이 0이거나 N이면 continue로 써서 얼음이 녹는단계를 진행하지 않았기 때문이었다  
회전만 안할뿐이지 녹아야 할 얼음은 녹는다..  










## 소스코드  
(시뮬문제는 문제조건을 복사해서 주석달고 그~대로 써서 소스가 좀 길다)  
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.StringTokenizer;

public class Main {

	private static int N, M, K;
	static int dx[] = { -1, -1, 0, 1, 1, 1, 0, -1 };
	static int dy[] = { 0, 1, 1, 1, 0, -1, -1, -1 };

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		N = Integer.parseInt(st.nextToken());
		M = Integer.parseInt(st.nextToken());
		K = Integer.parseInt(st.nextToken());
		ArrayList<Ball>[][][] balls = new ArrayList[N][N][2];
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < N; j++) {
				for (int k = 0; k < 2; k++) {
					balls[i][j][k] = new ArrayList<>();
				}
			}
		}

		int x, y, m, s, d;
		for (int i = 0; i < M; i++) {
			st = new StringTokenizer(br.readLine());
			x = Integer.parseInt(st.nextToken()) - 1;
			y = Integer.parseInt(st.nextToken()) - 1;
			m = Integer.parseInt(st.nextToken());
			s = Integer.parseInt(st.nextToken());
			d = Integer.parseInt(st.nextToken());
			balls[x][y][0].add(new Ball(m, s, d));
		}

		for (int i = 0; i < K; i++) {
//			1.모든 파이어스톰이 자신의 방향 di로 속력 si칸 만큼 이동한다.
			int flag = i % 2;
			int next = flag == 0 ? 1 : 0;
			for (int r = 0; r < N; r++) {
				for (int c = 0; c < N; c++) {
					while (!balls[r][c][flag].isEmpty()) {
						Ball curr = balls[r][c][flag].remove(0);
						int nx = r + dx[curr.d] * (curr.s % N);
						int ny = c + dy[curr.d] * (curr.s % N);
						nx = checkBoundary(nx);
						ny = checkBoundary(ny);
						balls[nx][ny][next].add(new Ball(curr.m, curr.s, curr.d));
					}
				}
			}

//			이동하는 중에는 같은 칸에 여러 개의 파이어스톰이 있을 수도 있다.
//			2.이동이 모두 끝난 뒤, 2개 이상의 파이어스톰이 있는 칸에서는 다음과 같은 일이 일어난다.
			for (int r = 0; r < N; r++) {
				for (int c = 0; c < N; c++) {
//			2-1.같은 칸에 있는 파이어스톰은 모두 하나로 합쳐진다.
//			2-2.파이어스톰은 4개의 파이어스톰로 나누어진다.
//			2-3-1.질량은 ⌊(합쳐진 파이어스톰 질량의 합)/5⌋이다.
//			2-3-2.속력은 ⌊(합쳐진 파이어스톰 속력의 합)/(합쳐진 파이어스톰의 개수)⌋이다.
					if (balls[r][c][next].size() > 1) {
						int ms = 0;
						int ss = 0;
						int v[] = new int[2];
						while (!balls[r][c][next].isEmpty()) {
							Ball curr = balls[r][c][next].remove(0);
							if (curr.d % 2 == 0)
								v[0]++;
							else
								v[1]++;
							ms += curr.m;
							ss += curr.s;
						}
						ms /= 5;
//			2-4.질량이 0인 파이어스톰은 소멸되어 없어진다.
						if (ms == 0)
							continue;
						int size = v[0] + v[1];
						ss /= size;
//			2-3-3.합쳐지는 파이어스톰의 방향이 모두 홀수이거나 모두 짝수이면, 방향은 0, 2, 4, 6이 되고, 그렇지 않으면 1, 3, 5, 7이 된다.
						int start = v[0] == 0 || v[1] == 0 ? 0 : 1;
						for (int k = start; k < 8; k += 2) {
							balls[r][c][next].add(new Ball(ms, ss, k));
						}
					}
				}
			}
		}
		// 마지막
		int total = 0;
		for (int i = 0; i < balls.length; i++) {
			for (int j = 0; j < balls.length; j++) {
				for (int k = 0; k < balls[i][j][K % 2].size(); k++) {
					total += balls[i][j][K % 2].get(k).m;
				}
			}
		}
		System.out.println(total);
	}

	private static int checkBoundary(int i) {
		if (i < 0)
			i += N;
		if (i >= N)
			i -= N;
		return i;
	}
}

class Ball {
	int m;
	int s;
	int d;

	public Ball(int m, int s, int d) {
		super();
		this.m = m;
		this.s = s;
		this.d = d;
	}
}
```